var DoAuthorBootstrapper;(()=>{"use strict";var o={d:(r,t)=>{for(var e in t)o.o(t,e)&&!o.o(r,e)&&Object.defineProperty(r,e,{enumerable:!0,get:t[e]})},o:(o,r)=>Object.prototype.hasOwnProperty.call(o,r),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},r={};o.r(r),o.d(r,{main:()=>t,observePeriodMsec:()=>e,observeMany:()=>i});const t=async()=>(window.sodium={onload:o=>{window.doauthor={server:"https://maja.doma.dev",saltSize:16,hashSize:32,keySize:32,defaultParams:{opsLimit:o.crypto_pwhash_OPSLIMIT_SENSITIVE,memLimit:5*o.crypto_pwhash_MEMLIMIT_MIN}},window.doauthor.crypto={},window.doauthor.crypto.show=r=>o.to_base64(r,o.base64_variants.URLSAFE),window.doauthor.crypto.read=r=>o.from_base64(r,o.base64_variants.URLSAFE),window.doauthor.crypto.slipConfig=()=>({ops:doauthor.defaultParams.opsLimit,mem:doauthor.defaultParams.memLimit,saltSize:doauthor.saltSize}),window.doauthor.crypto.mainKey=o=>{const r=localStorage.getItem("slip");if(r)return doauthor.crypto.mainKeyReproduce2(o,JSON.parse(r));{let[r,t]=doauthor.crypto.mainKeyInit2(o,doauthor.crypto.slipConfig());return localStorage.setItem("slip",JSON.stringify(t)),r}},window.doauthor.crypto.mainKeyInit2=(r,t)=>{const e={...t,salt:doauthor.crypto.show(o.randombytes_buf(t.saltSize))};return[doauthor.crypto.mainKeyReproduce2(r,e),e]},window.doauthor.crypto.mainKeyReproduce2=(r,t)=>{let{ops:e,mem:i,salt:a}=t;return o.crypto_pwhash(doauthor.hashSize,r,doauthor.crypto.read(a),e,i,o.crypto_pwhash_ALG_DEFAULT)},window.doauthor.crypto.deriveSigningKeypair=(r,t)=>{const e=o.crypto_kdf_derive_from_key(doauthor.keySize,t,"signsign",r);let{publicKey:i,privateKey:a}=o.crypto_sign_seed_keypair(e);return doauthor.did.memorisePublicKey(i),{public:i,secret:a}},window.doauthor.crypto.sign=(r,t)=>({public:t.public,signature:o.crypto_sign_detached(r,t.secret)}),window.doauthor.crypto.verify=(r,t)=>o.crypto_sign_verify_detached(t.signature,r,t.public),window.doauthor.crypto.bland_hash=r=>doauthor.crypto.show(o.crypto_generichash(doauthor.hashSize,r)),window.doauthor.crypto.sign_map=(o,r,t)=>{void 0===t&&(t={});const e={proofField:"proof",signatureField:"signature",keyField:"verificationMethod",keyFieldConstructor:o=>{const r=doauthor.crypto.show(o);return"did:doma:"+doauthor.crypto.bland_hash(r)},ignore:["id"]},i=Object.assign({},e,t);var a={...r};i.ignore.reduce(((o,r)=>{delete a[r]}));const d={...a},n=doauthor.crypto.canonicalise(d),u=doauthor.crypto.sign(JSON.stringify(n),o),c=i.keyFieldConstructor(o.public),s=doauthor.proof.from_signature(c,u.signature);var p={...r};return p[i.proofField]=s,p},window.doauthor.crypto.verify_map=(o,r)=>{void 0===r&&(r={});const t={proofField:"proof",signatureField:"signature",keyExtractor:o=>doauthor.did.fetchPublicKey(o.verificationMethod),ignore:["id"]},e=Object.assign({},t,r);var i={...o};const a=doauthor.crypto.canonicalise((e.ignore.concat(e.proofField).reduce(((o,r)=>{delete i[r]})),{...i}));var d,n=o[e.proofField];return d=Array.isArray(n)?[...n]:[n],[...d].reduce((async(o,r)=>{const t=await e.keyExtractor(r),i=(r[e.signatureField],{public:doauthor.crypto.read(t),signature:doauthor.crypto.read(r[e.signatureField])});return doauthor.crypto.verify(JSON.stringify(a),i)&&o}),!0)},window.doauthor.crypto.canonicalise=function o(r){if("string"==typeof r||"number"==typeof r||"bigint"==typeof r)return r;if("object"==typeof r){if(!0===Array.isArray(r))return r.map((r=>o(r)));{var t=Object.keys(r);const i={...r};t.sort();var e=new Array;for(let r=0;r<t.length;r++)e.push([t[r],o(i[t[r]])]);return e}}},window.doauthor.proof={},window.doauthor.proof.from_signature64=(o,r)=>({verificationMethod:o,signature:r,timestamp:doauthor.util.isoUtcNow()}),window.doauthor.proof.from_signature=(o,r)=>doauthor.proof.from_signature64(o,doauthor.crypto.show(r)),window.doauthor.credential={},window.doauthor.credential.from_claim=(o,r,t)=>{const e=doauthor.util.isoUtcNow();var i={"@context":[],type:[],issuer:doauthor.did.from_pk(o.public),issuanceDate:e,credentialSubject:r};return"object"==typeof t&&(["effectiveDate","validFrom","validUntil"].map((o=>{!(o in i)&&o in t&&(i[o]=t[o])})),["issuanceDate"].map((o=>{o in t&&(i[o]=t[o])}))),doauthor.crypto.sign_map(o,i)},window.doauthor.credential.proofless=o=>{ctxs=o["@context"];let{type:r,issuer:t,issuanceDate:e,credentialSubject:i}=o;return{"@context":ctxs,type:r,issuer:t,issuanceDate:e,credentialSubject:i}},window.doauthor.credential.prooflessJSON=o=>JSON.stringify(doauthor.crypto.canonicalise(doauthor.credential.proofless(o))),window.doauthor.credential.verify=(o,r)=>doauthor.crypto.verify(doauthor.credential.prooflessJSON(o),{public:r,signature:doauthor.crypto.read(o.proof.signature)}),window.doauthor.credential.verify64=(o,r)=>doauthor.credential.verify(o,doauthor.crypto.read(r)),window.doauthor.did={},window.doauthor.did.from_pk=o=>doauthor.did.from_pk64(doauthor.crypto.show(o)),window.doauthor.did.from_pk64=o=>"did:doma:"+doauthor.crypto.bland_hash(o),window.doauthor.did.recallPublicKey=o=>localStorage.getItem("pk|"+o),window.doauthor.did.fetchPublicKey=async o=>{var r=doauthor.did.recallPublicKey(o);return null===r&&(r=(await fetch(doauthor.server+"/did/public/"+o).then((o=>o.json))).public,doauthor.did.memorisePublicKey64(r)),r},window.doauthor.did.memorisePublicKey64=o=>localStorage.setItem("pk|"+doauthor.did.from_pk64(o),o),window.doauthor.did.memorisePublicKey=o=>doauthor.did.memorisePublicKey64(doauthor.crypto.show(o)),window.doauthor.util={},window.doauthor.util.prettyPrint=o=>JSON.stringify(o,null,2),window.doauthor.util.isoUtcNow=()=>(new Date).toISOString().slice(0,-5)+"Z",window.__doauthorHasLoaded__=!0}},new Promise(i((()=>[window.__doauthorHasLoaded__])))),e=30,i=(o,r)=>(t,a)=>{var d=void 0;if(o().reduce(((o,r)=>o&&r),!0))return t(o());if(void 0!==r){if(r>0)return a(new Error("Observer timed out"));d=r-e}return setTimeout(i(o,d).bind(void 0,t,a),e)};DoAuthorBootstrapper=r})();