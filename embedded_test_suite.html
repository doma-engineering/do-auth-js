<!doctype html>
<html>

<head>
    <title>doauthor demo</title>
</head>

<body>
    <label>Test ID:</label>
    <pre id="test-id"></pre>
    <label>Doauthor loading:</label>
    <div id="doauthor-status" class="test">pending</div>
    <label>URLSafe Base64 is tripping:</label>
    <div id="base64-suite" class="test">pending</div>
    <label>KDF works and makes valid signing keys:</label>
    <div id="kdf" class="test">pending</div>
    <ul>
        <li>
            <label>The slip:</label>
            <pre id="slip"></pre>
        </li>
        <li>
            <label>Signing key used:</label>
            <pre id="kdf-info"></pre>
        </li>
    </ul>
    <label>MainKeyInit2 generates a distinct key:</label>
    <div id="distinct" class="test">pending</div>
    <label>Main key gets reproduced from stored slip:</label>
    <div id="localstorage" class="test">pending</div>
    <label>"Verify map" of "sign map" is "true":</label>
    <div id="verify_map__sign_map" class="test">pending</div>
    <label>Credential compliance with the reference implementation:</label>
    <div id="credential-compatibility" class="test">pending</div>
    <pre id="credential-target">
    {
        "@context": [],
        "credentialSubject": {
            "hello": "world"
        },
        "issuanceDate": "2021-08-17T22:49:56Z",
        "issuer": "did:doma:JG8_wbJ-rpAWQF39eNoXp4XUXEPIZ4wnS3YOQto4B5Q=",
        "proof": {
            "signature": "2Sh0-cQ_HKcdwSNxycJkWIP_8O4SwnZHcqUaBSbMmoD0Tk-82L5LBEJnpY5MMgyClaA1UrLl5K49yB_b_91zBw==",
            "timestamp": "2021-08-17T22:49:56Z",
            "verificationMethod": "did:doma:JG8_wbJ-rpAWQF39eNoXp4XUXEPIZ4wnS3YOQto4B5Q="
        },
        "type": []
    }
    </pre>
    <label>Credentials are verifiable:</label>
    <div id="verifiable-credentials" class="test">pending</div>
</body>

<script src="/dist/doauthor.js"></script>
<script async defer src="/src/sodium.js"></script>
<script>
    const i = (x) => document.getElementById(x);
    const ok = (x) => { i(x).innerText = "ok" };
    const nok = (x) => { i(x).innerText = "fail" };
    const testLoaded = () => {
        if (__doauthorHasLoaded__ === true) {
            ok("doauthor-status");
        } else {
            nok("doauthor-status");
        }
    };
    const testBase64 = () => {
        const x = doauthor.crypto.show("show / read are tripping");
        if (x === doauthor.crypto.show(doauthor.crypto.read(x))) {
            ok("base64-suite");
        } else {
            nok("base64-suite");
        }
    };
    const password = "this is a password";
    const testMainKeyDerivation = () => {
        const show = doauthor.crypto.show;
        const mkey = doauthor.crypto.mainKey(password);
        const skp = doauthor.crypto.deriveSigningKeypair(mkey, 4);
        const msg = "this is an authenticated message";
        const detachedSig = doauthor.crypto.sign(msg, skp);
        if (true === doauthor.crypto.verify(
            msg,
            detachedSig
        )) {
            ok("kdf");
            i("slip").innerText =
                doauthor.util.prettyPrint(JSON.parse(localStorage.getItem("slip")));
            i("kdf-info").innerText =
                doauthor.util.prettyPrint({
                    "public": show(detachedSig.public),
                    "signature": show(detachedSig.signature)
                });
        } else {
            nok("kdf");
        }
        return mkey;
    }
    const testCryptoVerifyMapOfSignMapIsTrue = async (skp) => {
        const verifiable_map = doauthor.crypto.sign_map(skp, { "hello": { "dangerous": { "world": ["of", "JavaScript"] } } });
        const res = await doauthor.crypto.verify_map(verifiable_map);
        if (true === res) {
            ok("verify_map__sign_map");
        } else {
            nok("verify_map__sign_map");
        }
    }
    const testMainKeyInit2GeneratesDistinctKey = (mkey0) => {
        const show = doauthor.crypto.show;
        const mkey = doauthor.crypto.mainKey(password);
        const [mkey1, _slip] = doauthor.crypto.mainKeyInit2(password, doauthor.crypto.slipConfig());
        if (show(mkey) !== show(mkey1)) {
            ok("distinct");
        } else {
            nok("distinct");
        }
        if (show(mkey0) === show(mkey)) {
            ok("localstorage");
        } else {
            nok("localstorage");
        }
        return doauthor.crypto.deriveSigningKeypair(mkey, 20);
    }
    const testCredentialCompatibility = () => {
        const kp = {
            "public": doauthor.crypto.read("dW8Z2z2icecILIyAdrjaOqkurfC99ocFR87r9QX_mJQ="),
            "secret": doauthor.crypto.read("H9xUHnIAxdYuslQ8UULO8A0eXf6gH2ySEfo2-kdZZow32Nza1n_O_YdP4Qg7JuCbt8ieMOZkFypb-UbAWVLKCg==")
        };
        const cred_ours = doauthor.credential.from_claim(kp, { "hello": "world" }, { "issuanceDate": "2021-08-17T22:49:56Z" });
        const cred_ref = JSON.parse(i("credential-target").innerText);
        const our_sig = cred_ours["proof"]["signature"];
        const ref_sig = cred_ref["proof"]["signature"];
        if (our_sig === ref_sig) {
            ok("credential-compatibility");
        } else {
            nok("credential-compatibility");
        }
        doauthor.did.memorisePublicKey(kp["public"]);
        if (doauthor.crypto.verify_map(cred_ours)) {
            ok("verifiable-credentials");
        } else {
            nok("verifiable-credentials");
        }
    }
    (async () => {
        const promise = DoAuthorBootstrapper.main()
        promise.then(
            async () => {
                i("test-id").innerText = doauthor.crypto.show(sodium.randombytes_buf(8));
                testLoaded();
                testBase64();
                const mkey = testMainKeyDerivation();
                const skp = testMainKeyInit2GeneratesDistinctKey(mkey);
                await testCryptoVerifyMapOfSignMapIsTrue(skp);
                testCredentialCompatibility();
            }
        )
    })();
</script>

</html>
